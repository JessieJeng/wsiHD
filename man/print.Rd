% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fnpOpt.R
\name{fnpOpt}
\alias{fnpOpt}
\alias{fnpOpt,ANY,ANY-method}
\alias{fnpOpt,ANY,matrix-method}
\alias{fnpOpt,ANY,big.matrix-method}
\alias{fnpOpt,ANY,ff_matrix-method}
\alias{fnpOpt,numeric,missingOrNull-method}
\alias{fnpOpt,matrix,missingOrNull-method}
\alias{fnpOpt,big.matrix,missingOrNull-method}
\alias{fnpOpt,ff_matrix,missingOrNull-method}
\alias{fnpOpt,ff_array,missingOrNull-method}
\alias{fnpOpt,ff_vector,missingOrNull-method}
\title{Dual Control Procedure}
\usage{
fnpOpt(pval, pval_null, ...)

\S4method{fnpOpt}{ANY,ANY}(pval, pval_null, ...)

\S4method{fnpOpt}{ANY,matrix}(pval, pval_null, beta, alpha = 0.1)

\S4method{fnpOpt}{ANY,big.matrix}(pval, pval_null, beta, alpha = 0.1)

\S4method{fnpOpt}{ANY,ff_matrix}(pval, pval_null, beta, alpha = 0.1)

\S4method{fnpOpt}{numeric,missingOrNull}(pval, pval_null, beta, sHat)

\S4method{fnpOpt}{matrix,missingOrNull}(pval, pval_null, ...)

\S4method{fnpOpt}{big.matrix,missingOrNull}(pval, pval_null, beta, sHat)

\S4method{fnpOpt}{ff_matrix,missingOrNull}(pval, pval_null, ...)

\S4method{fnpOpt}{ff_array,missingOrNull}(pval, pval_null, ...)

\S4method{fnpOpt}{ff_vector,missingOrNull}(pval, pval_null, beta, sHat)
}
\arguments{
\item{pval}{A numeric vector object, a big.matrix object with a
single row or col, or an ff_vector, ff_array of single dimension, or
ff_matrix with a single row or col {p}. The p-values. See Details.}

\item{pval_null}{A numeric matrix object, a big.matrix object, or an
ff_matrix object of dimension {p x n}. The p-values generated 
from the null distribution. The columns correspond to the samples (n),
the rows to the signal variabless (p). If not provided (i.e., missing or),
NULL) inputs c05 and c1 must be provided. If pval_null is provided, only
input alpha is required. See Details.}

\item{...}{Ignored.}

\item{beta}{A numeric object. The threshold.}

\item{alpha}{A numeric object. The significance level. The bounding sequence
is estimated as the (1-alpha)-th quantile. This input is required only if
pval_null is provided as input. See Details.}

\item{sHat}{A numeric object. The estimated number of signal variables. 
This input is required only if pval_null is not provided as input. See 
Details.}
}
\value{
An S3 object of class wsiHD comprising a list object. 
  The exact contents depend on the input combination.
  The list will always include elements:
  \item{ind}{The rank of the variables satisfying the threshold condition.}
  \item{pvalue}{The maximum p-value for variables satisfying the threshold condition.}
  \item{FNP}{A vector of the p FNP estimates. The class of this object
     will depend on the class of pval.}
  If the signal proportion is estimated internally, the list will also 
  include
  \item{c05}{Estimated bounding sequence when delta is set to the
      square root of the p-value.}                 
  \item{c1}{Estimated bounding sequence when delta is set equal
      to the p-value.}
  \item{piHat}{Estimated signal proportion.}
  \item{piHat05}{Estimated signal proportion when delta is set to the
      square root of the p-value.}                 
  \item{piHat1}{Estimated signal proportion when delta is set equal
      to the p-value.}
}
\description{
Implements a dual control method for signal selection.
}
\details{
This function is multi-use in the sense that the algorithm depends on the
  combination of inputs provided. If inputs pval, beta, and sHat are provided,
  the function uses the provided estimated number of signals (sHat) 
  to estimate the FNP. In contrast, if inputs pval, 
  pval_null, beta, and alpha are provided, the function uses pval_null and 
  alpha to estimate the number of signals, which is then used to estimate 
  the FNP. This latter scenario is equivalent to calling 
  cSeq(pval_null, alpha) to obtain c05 and c1, providing these as
  inputs to signalProp(pval, c05, c1) to obtain piHat, and then providing 
  sHat = ceiling(p*piHat) as input to fnp(pval, beta, sHat).

The null p-values can be provided as a numeric matrix, a big.matrix as defined
  by the bigmemory package, or as an ff_matrix as defined by the ff package.
  The latter two options allow for larger matrices. Please see the 
  documentation of these packages for details on creating objects. 

The p-values can be provided as a numeric vector, a big.matrix with a single
  column or row, or as an ff object of class (ff_vector, ff_array of 1
  dimension or ff_matrix with a single column or row).
  The latter two options allow for larger vectors.  

Note that if both pval and pval_null are provided as input, they
  do not have to "match." For example pval can be
  a standard numeric vector with pval_null specified as a big.matrix.

If estimating the bounding sequence, note that the quantile() function of 
  base R provides 9 algorithms for estimating
  the quantile, which are based on the definitions of Hyndman and Fan (1996). 
  We have chosen the default (type = 7) here. However,
  the quantile algorithm implemented in Armadillo is type = 5 and that
  of ff is type = 1.
  Thus the results obtained using base, bigmemory, and ff objects
  containing equivalent data might differ slightly.
}
\examples{

   data(wsiData)

   # limit data to expedite example
   smp <- sample(x = 2:4089, size = 500, replace = FALSE)

   Sigma <- stats::cor(x = wsiData[,smp])

   n <- 100L
   p <- ncol(x = Sigma)

   zz <- MASS::mvrnorm(n = n, mu = rep(x = 0.0, times = p), Sigma = Sigma)
   pval_null <- {1.0 - stats::pnorm(q = abs(x = zz))}*2.0

   pval <- stats::runif(n = p)

   cseq <- cSeq(pval_null = pval_null, alpha = 0.1)
   piHat <- signalProp(pval = pval, c05 = cseq$c05, c1 = cseq$c1)
   sHat <- ceiling(x = piHat$piHat*p)
   fnpOpt(pval = pval, beta = 0.1, sHat = sHat)

   # or equivalently obtained in one step as
   fnpOpt(pval = pval, pval_null = pval_null, alpha = 0.1, beta = 0.1)

}
\references{
Jeng, X. J. and Hu, Y (2021). 
    Weak Signal Inference Under Dependence and Sparsity, submitted.
}
